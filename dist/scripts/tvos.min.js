// extensions.js
// (c) Dmitry Sadakov - 2015 All rights reserved.

'use strict';

if (typeof String.prototype.endsWith !== 'function') {
	String.prototype.endsWith = function (suffix) {
		return this.indexOf(suffix, this.length - suffix.length) !== -1;};}



if (typeof String.prototype.startsWith !== 'function') {
	String.prototype.startsWith = function (prefix) {
		return this.indexOf(prefix) !== -1;};}




if (typeof Promise !== 'undefined' && Promise) {
	Promise.any = function (arrayOfPromises) {
		if (!arrayOfPromises || !(arrayOfPromises instanceof Array)) {
			throw new Error('Must pass Promise.any an array');}


		if (arrayOfPromises.length === 0) {
			return Promise.resolve([]);}



		// For each promise that resolves or rejects, 
		// make them all resolve.
		// Record which ones did resolve or reject
		var resolvingPromises = arrayOfPromises.map(function (promise) {
			return promise.then(function (result) {
				return { 
					resolve: true, 
					result: result };}, 

			function (error) {
				return { 
					resolve: false, 
					result: error };});});




		return Promise.all(resolvingPromises).then(function (results) {
			// Count how many passed/failed
			var passed = [], failed = [], allFailed = true;
			results.forEach(function (result) {
				if (result.resolve) {
					allFailed = false;}

				if (result.resolve) {
					passed.push(result.result);} else 
				{
					failed.push(result.result);}});



			if (allFailed) {
				throw failed;} else 
			{
				return passed;}});};}
/*
 *  Copyright 2015 Dmitry Sadakov. All rights reserved.
 */

'use strict';var _createClass = (function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};})();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}var 

AjaxLite = (function () {function AjaxLite() {_classCallCheck(this, AjaxLite);}_createClass(AjaxLite, null, [{ key: 'ajax', value: function ajax(
    options) {
      var url = options.url;
      var type = options.type || 'GET';
      var headers = options.headers || {};
      var body = options.data || null;
      var timeout = options.timeout || 1000;
      var success = options.success || function () {
        console.log('options.success was missing for this request');};

      var contentType = options.contentType || 'application/json';
      var error = options.error || function () {
        console.log('options.error was missing for this request');};


      if (!url) {
        error(null, 'loadURL requires a url argument');}


      var xhr = new XMLHttpRequest();
      xhr.contentType = 'json';
      xhr.timeout = timeout;
      xhr.ontimeout = function () {
        // error(xhr, 'timeout', xhr.response);
      };
      xhr.onreadystatechange = function () {
        //try {
        if (xhr.readyState === 4) {
          if (xhr.contentType === 'json') {
            if (xhr.responseText === '') {
              xhr.responseJSON = null;} else 
            {
              xhr.responseJSON = JSON.parse(xhr.responseText);}}


          if (xhr.status === 200) {
            success(xhr.responseJSON || xhr.responseText, 'success', xhr);} else 
          if (xhr.status === 0) {
            // xhr.statusText = 'timeout';
            error(xhr, 'timeout', xhr.response);} else 
          {
            error(xhr, 'error', xhr.response);}}


        //} catch (err) {
        //  console.error(`Aborting request ${url}. Error: ${err}`);
        //  xhr.abort();
        //  error(xhr, 'error', xhr.response);
        //}
      };

      xhr.open(type, url, true);

      xhr.setRequestHeader('Content-Type', contentType);
      xhr.setRequestHeader('Accept', 'application/json, text/javascript, */*');

      Object.keys(headers).forEach(function (key) {
        xhr.setRequestHeader(key, headers[key]);});


      console.log('AjaxLite sending: ' + url);
      if (body) {
        xhr.send(body);} else 
      {
        xhr.send();}


      return xhr;} }]);return AjaxLite;})();
// localstorage interface

'use strict'
/*jshint multistr: true */

/*globals chrome:false */

/* exported Storage */;var _createClass = (function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};})();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}var 

Storage = (function () {function Storage() {_classCallCheck(this, Storage);}_createClass(Storage, null, [{ key: 'set', value: function set(
		name, val) {var _this = this;
			return new Promise(function (resolve, reject) {
				try {
					console.log('setting ' + name + ' = ' + JSON.stringify(val));
					var obj = {};
					obj[name] = val;

					if (_this.syncAvailable()) {
						chrome.storage.sync.set(obj, resolve);} else 
					{
						localStorage.setItem(name, JSON.stringify(val));
						resolve(name, val); // might be different from sync
					}} 
				catch (e) {
					reject(e);}});} }, { key: 'get', value: function get(




		name) {var _this2 = this;
			return new Promise(function (resolve, reject) {
				if (_this2.syncAvailable()) {
					chrome.storage.sync.get(name, function (items) {
						console.log('got storage ' + name + ': ' + items[name]);
						resolve(items[name]);});} else 

				if (localStorage) {
					var result = null;
					try {
						var b = localStorage.getItem(name);
						if (b === 'undefined') {
							result = undefined;} else 
						if (b === 'null') {
							result = null;} else 
						{
							result = JSON.parse(b);}} 

					catch (e) {
						console.log('Error: ' + e);
						result = localStorage.getItem(name);}

					resolve(result);} else 
				{
					resolve(null);}});} }, { key: 'syncAvailable', value: function syncAvailable() 



		{
			return typeof chrome !== 'undefined' && 
			chrome.storage !== undefined && 
			chrome.storage.sync !== undefined;} }]);return Storage;})();
/**
 * Copyright (c) 2015 Dmitry Sadakov; All rights reserve
*/

'use strict'

/*globals trackState,AjaxLite */
/*exported HueDiscoverer */;var _createClass = (function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};})();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}var 

MeetHueLookup = (function () {
    function MeetHueLookup(AjaxLite) {_classCallCheck(this, MeetHueLookup);
        this.AjaxLite = AjaxLite;}_createClass(MeetHueLookup, [{ key: 'discover', value: function discover() 

        {var _this = this;
            return new Promise(function (resolveCallback, reject) {
                console.log('Requesting meethue.com/api/nupnp.');
                var nupnp = 'https://www.meethue.com/api/nupnp';
                _this.AjaxLite.ajax({ 
                    url: nupnp, 
                    dataType: 'json', 
                    success: function success(data) {
                        trackState('nunpnp', data);
                        if (data !== null && data.length > 0) {
                            var ips = [];
                            data.forEach(function (bridgeInfo, index) {
                                var bridgeIP = bridgeInfo.internalipaddress;
                                if (bridgeIP !== '0.0.0.0') {
                                    ips.push(bridgeIP);}});


                            resolveCallback(ips);} else 
                        {
                            console.log('meethue portal did not return');
                            reject([]);}}, 


                    error: function error(err) {
                        reject(err);} });});} }]);return MeetHueLookup;})();var 






BruteForcer = (function () {function BruteForcer() {_classCallCheck(this, BruteForcer);}_createClass(BruteForcer, null, [{ key: 'ips', value: function ips() 
        {
            var ips = [];
            var i = 0;
            for (i = 1; i < 8; i++) {ips.push('10.0.1.' + i);} // mac: 10.0.1.1-20
            for (i = 1; i < 8; i++) {ips.push('192.168.0.' + i);} // win: 192.168.0.1-20
            for (i = 0; i < 8; i++) {ips.push('192.168.0.' + (100 + i));} // win: 192.168.1.100-120
            for (i = 1; i < 8; i++) {ips.push('192.168.1.' + i);} // win: 192.168.1.1-20

            return ips;} }]);return BruteForcer;})();var 



HueBridge = (function () {_createClass(HueBridge, [{ key: 'status', value: function status() 

        {
            return this.status;} }]);


    function HueBridge($, storage, bridgeIP, appName, lastUsername, onNeedAuthorization, onAuthorized, onError, retryCount) {_classCallCheck(this, HueBridge);
        // todo: remove storage from HueBridge
        this.$ = $;

        // defaults
        if (!lastUsername) {
            lastUsername = '123-bogus';}

        this.ip = bridgeIP;
        this.appname = appName;
        this.username = lastUsername;

        this.baseUrl = 'http://' + this.ip + '/api';
        this.baseApiUrl = this.baseUrl + '/' + this.username;
        this.status = 'init'; // found, notauthorized, ready, error

        this.timeoutAuthCounter = 0;
        this.retryCount = retryCount || 0;

        this.onNeedAuthorization = onNeedAuthorization;
        this.onAuthorized = onAuthorized;
        this.onError = onError;}_createClass(HueBridge, [{ key: 'log', value: function log(



        text) {
            var message = 'hueBridge (' + this.ip + '): ' + text;
            console.log(message);} }, { key: 'getLightState', value: function getLightState(

        successCallback) {var _this2 = this;
            try {
                var options = { 
                    dataType: 'json', 
                    url: this.baseApiUrl + '/lights', 
                    success: function success(data) {
                        _this2.timeoutAuthCounter = 0;
                        _this2.onGotLightState(data, successCallback);
                        //this.onGotBridgeState(data, successCallback); // lighter bag of data
                    }, 
                    error: function error(data) {return _this2.onAuthError(data);}, 
                    timeout: 2000 };

                this.$.ajax(options);} 
            catch (err) {
                this.onAuthError(err);}} }, { key: 'getBridgeState', value: function getBridgeState() 


        {var _this3 = this;
            try {
                var options = { 
                    dataType: 'json', 
                    url: this.baseApiUrl, 
                    success: function success(data) {return _this3.onGotBridgeState(data);}, 
                    error: function error(data) {return _this3.onAuthError(data);}, 
                    timeout: 5000 };

                this.$.ajax(options);} 
            catch (err) {
                this.onAuthError(err);}} }, { key: 'onAuthError', value: function onAuthError(


        err) {
            if (err.statusText === 'timeout' || err.status === 0) {
                this.timeoutAuthCounter++;
                this.log('Bridge error timeout: ' + this.ip);
                if (this.timeoutAuthCounter >= this.retryCount) {
                    this.timeoutAuthCounter = 0;
                    if (this.retryCount !== 0) {
                        this.log('too many timeouts with IP ' + this.baseUrl);}

                    this.onError(this.ip, 'Timeout', 'Too many timeouts on: ' + this.baseUrl);} else 
                {
                    this.log('timeout on auth: ' + err.statusText + ' retry #' + this.timeoutAuthCounter);
                    this.getBridgeState(); // retry
                }} else 
                {//if (err.statusText !== 'error') {
                    this.log('error on auth: ' + err.statusText);
                    this.status = 'error';
                    this.onError(this.ip, 'Error', 'Unknown error: ' + err.statusText);}
            // what now?
        } }, { key: 'onGotLightState', value: function onGotLightState(
        data, successCallback) {
            if (data.hasOwnProperty('1') && 
            data['1'].hasOwnProperty('manufacturername')) {
                // indeed a light response.
                data = { 'lights': data };}

            this.onGotBridgeState(data, successCallback);} }, { key: 'onGotBridgeState', value: function onGotBridgeState(

        data, successCallback) {
            if (Array.isArray(data)) {
                data = data[0]; // take first
            }
            this.timeoutAuthCounter = 0;
            if (data.hasOwnProperty('error')) 
            {
                if (data.error.description === 'unauthorized user') {
                    this.log('Not authorized with bridge ' + this.ip + ', registering...');
                    this.retryCounter++;
                    this.status = 'found';
                    // bridgeAuth
                    this.addUser();} else 
                {
                    this.status = 'error';
                    this.onError(this.ip, 'Error', 'Error: ' + data.error.description);}} else 


            if (data.hasOwnProperty('lights')) 
            {
                this.status = 'ready';
                this.log('Bridge ready ' + this.ip);
                this.retryCounter = 0;
                (successCallback || this.onAuthorized)(this, this.ip, this.username, 'Ready', data);}} }, { key: 'addUser', value: function addUser() 


        {var _this4 = this;
            this.log('adding user...');
            var dataString = JSON.stringify({ devicetype: this.appname }); // no username - bridge generates it
            this.log(dataString);
            this.$.ajax({ 
                url: this.baseUrl, 
                type: 'POST', 
                data: dataString, 
                success: function success(data) {return _this4.onAddUserResponse(data);} });} }, { key: 'onAddUserResponse', value: function onAddUserResponse(


        response) {
            this.log(JSON.stringify(response));
            if (response[0].hasOwnProperty('error')) 
            {
                this.unauthorized(response);} else 

            if (response[0].hasOwnProperty('success')) 
            {
                this.username = response[0].success.username;
                this.baseApiUrl = this.baseUrl + '/' + this.username;
                this.status = 'ready';
                this.log('Authorization successful');
                // request success message from actual bridge:
                this.getBridgeState();}} }, { key: 'unauthorized', value: function unauthorized(


        response) {
            if (response[0].error.description === 'link button not pressed') {
                this.status = 'needauthorization';
                this.onNeedAuthorization(this.ip, this.username, 'NeedAuthorization', response); // changed signature
                this.onError(this.ip, 'Error', 'Need authentication: ' + response[0].error.description);} else 
            {
                this.status = 'error';
                this.onError(this.ip, 'Error', 'Error: ' + response[0].error.description);}} }, { key: 'ip', value: function ip() 


        {
            return this.ip;} }, { key: 'username', value: function username() 

        {
            return this.username;} }, { key: 'getStatus', value: function getStatus() 

        {
            return this.status;} }]);return HueBridge;})();var 





HueDiscoverer = (function () {
    function HueDiscoverer(AjaxLite, storage, appname, onNeedAuthorization) {_classCallCheck(this, HueDiscoverer);
        this.AjaxLite = AjaxLite;
        this.storage = storage;
        this.appname = appname;
        this.onNeedAuthorization = onNeedAuthorization;
        self = this;}_createClass(HueDiscoverer, [{ key: 'bridgeThenable', value: function bridgeThenable(

        ip) {var _this5 = this;
            var bridgeThenable = new Promise(function (resolve, reject) {
                if (!ip) {
                    reject(ip);
                    return;}


                var bridge = null;

                function onResolve(ip, status, message) {
                    resolve(bridge, ip, status, message);}

                function onReject(ip, status, message) {
                    reject(bridge, ip, status, message);}


                bridge = new HueBridge(_this5.AjaxLite, _this5.storage, ip, _this5.appname, _this5.username, 
                _this5.onNeedAuthorization, 
                function (ip, status, message) {return onResolve(bridge, status, message);}, 
                function (ip, status, message) {return onReject(bridge, status, message);});
                bridge.getLightState();});

            return bridgeThenable;} }, { key: 'start', value: function start(

        ip) {
            function getIP() {
                return this.storage.get('lastBridgeIp');}

            function getUsername() {
                return this.storage.get('lastUsername');}

            function saveIP(ip) {
                this.ip = ip;}

            return new Promise(function (resolve, reject) {

                var promise = self.storage.get('lastBridgeIp').
                then(function (ip) {
                    self.ip = ip;
                    return self.storage.get('lastUsername');}).

                then(function (val) {return self.username = val;}).
                then(function () {
                    var promises = [];
                    if (ip) {
                        promises.push(self.bridgeThenable(ip)); // from arguments
                    }
                    if (self.ip) {
                        promises.push(self.bridgeThenable(self.ip)); // from storage
                    }
                    return promises.length != 0 ? Promise.any(promises) : Promise.reject();}).

                catch(function () {
                    var promises = [];
                    var meethuePromise = new Promise(function (resolve, reject) {
                        return new MeetHueLookup(self.AjaxLite).discover().then(function (ips) {
                            var bridges = [];var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
                                for (var _iterator = ips[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var i = _step.value;
                                    bridges.push(self.bridgeThenable(i));}} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator.return) {_iterator.return();}} finally {if (_didIteratorError) {throw _iteratorError;}}}

                            Promise.any(bridges).then(function (bridges) {return resolve(bridges[0]);}, function () {return reject();});}, 
                        function () {return reject();});});

                    promises.push(meethuePromise);

                    var ips = BruteForcer.ips();var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {
                        for (var _iterator2 = ips[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var i = _step2.value;
                            promises.push(self.bridgeThenable(i)); // 84 requests
                        }} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2.return) {_iterator2.return();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}
                    return Promise.any(promises);}).

                then(function (bridges) {
                    self.storage.set('lastBridgeIp', bridges[0].ip);
                    self.storage.set('lastUsername', bridges[0].username);
                    resolve(bridges[0]);}).

                catch(function () {
                    reject();});


                //resolve();
                return promise;});} }]);return HueDiscoverer;})();
/**
 * Dmitry Sadakov's Philips Hue api wrapper, exposed as an AMD module.
 * Dependencies:
 *    - jQuery 1.8.3
 *    - colors.js (packaged alongside this file)
 * Copyright 2014 Dmitry Sadakov, All rights reserved.
 * original: https://github.com/bjohnso5/hue-hacking
 * Copyright (c) 2013 Bryan Johnson; Licensed MIT */

'use strict'

/*globals colorUtil:false, HueDiscoverer, AjaxLite, Storage, HueBridge
*/
/*trackEvent*/
/*exported  hue, 
            findActors, 
            findGroupIdByName 
*/

// extract hueBridge class (with ip, username, authentication logic)
// todo: remove authentication logic - forward to bridge class
// on start check setup (ip & username) and do fast start.
;
var hue = function hue($, colors) {

    var discover = null;
    var discoverStatus = 'init';


    var bridge = null, 
    bridgeIP = '', // Hue bridge's IP address 
    appname = 'lightswitch-v5', // API key registered with hue bridge
    username = '', 
    status = { status: 'init', text: 'Initializing...' }, // system status
    state = null, // bridge state

    // defaults
    baseUrl = 'http://' + bridgeIP + '/api', 
    baseApiUrl = null, //baseUrl + '/' + appname,
    lightApiUrl = null, // baseApiUrl + '/lights',
    lastResult = null, 
    numberOfLamps = 3, // defaulted to the # of lamps included in the starter kit, update if you've connected additional bulbs

    // lamp states:
    shortFlashType = 'select', 
    longFlashType = 'lselect', 
    offState = { on: false }, 
    onState = { on: true }, 
    shortFlashState = { alert: shortFlashType }, 
    longFlashState = { alert: longFlashType }, 
    transitionTime = null, 
    errorCounter = 0;

    //discover = hueDiscoverer(appname, onNeedAuthorization, onIpAuthorized, onError, onComplete);
    discover = new HueDiscoverer(AjaxLite, Storage, appname, onNeedAuthorization);

    var statusInit = { status: 'init', text: 'Initializing...' };
    var statusNeedAuth = { status: 'Authenticating', text: 'Bridge found. Press the bridge button...' };
    //var statusNoBridge = {status: 'BridgeNotFound', text: 'Philip Hue bridge not found.'};
    //var statusReady = {status: 'OK', text: 'Lights found.'};

    function onNeedAuthorization(ip) {
        statusNeedAuth.text = 'Bridge found at ' + ip + '.<br >Press the bridge button...';
        onStatus(statusNeedAuth);
        discoverStatus = 'auth';}


    function onBridgeError(err) {
        console.log('onBridgeError' + err);
        onError(err);}


    function onIpAuthorized(bridgeAuthorized, ip, usernameArg, message, data) {

        //if(bridge === null || !(ip === bridge.ip() && username === bridge.username())) {
        bridge = new HueBridge(
        AjaxLite, 
        Storage, 
        bridgeAuthorized.ip, 
        appname, 
        bridgeAuthorized.username, 
        onNeedAuthorization, 
        onIpAuthorized, 
        onBridgeError, 
        10);
        discoverStatus = 'ok';

        bridgeIP = bridge.ip;
        username = bridge.username;
        updateURLs();

        //} 

        if (data === undefined) {
            bridge.getBridgeState();} else 
        {
            onNewState(data); // safe to delete
        }}


    function onDiscoverError(ip, msg, text) {
        //onStatus(statusNoBridge);
        if (status !== null) {
            if (status.status !== statusNeedAuth.status) {
                updateStatus('BridgeNotFound', 'Philip Hue bridge not found.');} else 
            {
                // discover:
                setTimeout(function () {return rediscover();}, 2000);}}}




    function rediscover(ip) {
        discover.start(ip).then(function (bridge, ip, username, message, data) {
            onIpAuthorized(bridge, ip, username, message, data);}, 

        function (ip, msg, text) {
            onDiscoverError(ip, msg, text);});


        updateStatus(statusInit.status, statusInit.text);}


    function onError(ip, msg, text) {
        updateStatus('BridgeNotFound', 'Philip Hue bridge not found.');}


    var onLampError = function onLampError(err) {
        // do nothing for now.
        errorCounter++;}, 

    /**
     * Reconstruct the baseUrl and baseApiUrl members when configuration is updated.
     */
    updateURLs = function updateURLs() {
        baseUrl = 'http://' + bridgeIP + '/api';
        baseApiUrl = baseUrl + '/' + username;
        lightApiUrl = baseApiUrl + '/lights';}, 

    /**
     * Sets the response to the lastResult member for use. Currently unused.
     *
     * @param {String} Response data as a String
     * @param {String} Status text
     * @param {jqXHR} jQuery XmlHttpResponse object
     */
    apiSuccess = function apiSuccess(data, successText, jqXHR) {
        lastResult = data;
        log(JSON.stringify(lastResult));}, 


    /**
     * Convenience function to perform an asynchronous HTTP PUT with the
     * provided JSON data.
     *
     * @param {String} url The URL to send the PUT request to.
     * @param {Function} callback The function to invoke on a successful response.
     * @param {Object} data The JSON data.
     * @return {Object} The JSON data.
     */
    putJSON = function putJSON(url, callback, error, data) {
        var options = { 
            type: 'PUT', 
            url: url, 
            success: callback, 
            error: error || onLampError, 
            dataType: 'json', 
            contentType: 'application/json', 
            data: JSON.stringify(data) };

        $.ajax(options);
        //log(JSON.stringify(options));
        return data;}, 


    postJSON = function postJSON(url, callback, error, data) {
        var options = { 
            type: 'POST', 
            url: url, 
            success: callback, 
            error: error || onLampError, 
            dataType: 'json', 
            contentType: 'application/json', 
            data: JSON.stringify(data) };

        $.ajax(options);
        //log(JSON.stringify(options));
        return data;}, 


    del = function del(url, callback, error, data) {
        var options = { 
            type: 'DELETE', 
            url: url, 
            success: callback, 
            error: error || onLampError };

        $.ajax(options);
        log(JSON.stringify(options));}, 


    /**
     * Convenience function used to query the state of a Hue lamp or other
     * bridge-administered resource.
     *
     * @param {String} destination URL to send HTTP GET request to.
     * @param {Function} success Callback function to invoke on successful response.
     * @return {Object} JSON bulb configuration data.
     */
    get = function get(destination, _success, error) {
        var callback = _success || null;
        callback = null === callback ? apiSuccess : _success;

        $.ajax({ 
            dataType: 'json', 
            url: destination, 
            success: function success(data) {
                _success(data);}, 

            error: error, 
            timeout: 2000 });}, 



    /**
     * Convenience function used to build a state URL for a provided Hue lamp
     * index.
     *
     * @param {Number} lampIndex 1-based index of the Hue lamp.
     * @return {String} URL to put state to a lamp.
     */
    buildStateURL = function buildStateURL(lampIndex /* Number */) {
        return baseApiUrl + '/lights/' + lampIndex + '/state';}, 


    /**
     * Convenience function used to build a state URL for a provided Hue lamp
     * group.
     *
     * @param {Number} groupIndex 0-based index of the lamp group.
     * @return {String} URL to trigger a group action.
     */
    buildGroupActionURL = function buildGroupActionURL(groupIndex /* {Number} */) {
        return baseApiUrl + '/groups/' + groupIndex + '/action';}, 


    buildGroupURL = function buildGroupURL(key) {
        if (key !== undefined) {
            return baseApiUrl + '/groups/' + key;}

        return baseApiUrl + '/groups';}, 


    /**
     * Convenience function used to initiate an HTTP PUT request to modify 
     * state.
     *
     * @param {Number} lampIndex 1-based index of the Hue lamp to modify.
     * @param {String} data String containing the JSON state object to commit to the lamp.
     * @param {Function} success Callback function to invoke on successful response.
     * @return {Object} JSON bulb state data.
     */
    put = function put(lampIndex, data, success, error) {
        var callback = success || null;
        callback = null === callback ? apiSuccess : success;
        return putJSON(buildStateURL(lampIndex), callback, error, data);}, 


    /**
     * Convenience function used to initiate an HTTP PUT request to modify state of a group of lamps.
     *
     * @param {Number} Index of the lamp group to modify
     * @param {Object} Object containing desired lamp state
     * @return {Object} JSON bulb group state data.
     */
    putGroupAction = function putGroupAction(groupIndex /* {Number} */, action /* String */) {
        var callback = apiSuccess;
        var error = log;
        return putJSON(buildGroupActionURL(groupIndex), callback, error, action);}, 


    postGroup = function postGroup(name, lampIds) {
        var callback = apiSuccess;
        var error = log;
        var state = { name: name, lights: lampIds };
        return postJSON(buildGroupURL(), callback, error, state);}, 

    deleteGroup = function deleteGroup(key) {
        var callback = apiSuccess;
        var error = log;
        return del(buildGroupURL(key), callback, error);}, 

    /**
     * Convenience function used to initiate HTTP PUT requests to modify state
     * of all connected Hue lamps.
     *
     * @param {String} data String containing the JSON state object to commit to the lamps.
     * @param {Function} success Callback function to invoke on successful response.
     * @return {Object} JSON object containing state to apply to lamp.
     */
    putAll = function putAll(data, success, error) {
        var callback = success || null;
        callback = null === callback ? apiSuccess : success;

        for (var i = 0; i < numberOfLamps; ++i) {
            putJSON(buildStateURL(i + 1), callback, error, data);}

        return data;}, 


    /**
     * Convenience function used to build a URL to query a lamp's status.
     *
     * @param {Number} lampIndex 1-based index of the Hue lamp.
     * @return {String} URL to query a specific lamp.
     */
    buildLampQueryURL = function buildLampQueryURL(lampIndex /* Number */) {
        return baseApiUrl + '/lights/' + lampIndex;}, 


    /** 
     * Builds a JSON state object for the CIE 1931 color coordinates provided.
     * If the transitionTime property has been set, it is also included in the
     * JSON object.
     *
     * @param {Number[]} CIE 1931 X,Y color coordinates.
     * @return {Object} State object containing CIE X,Y coordinates.
     */
    buildXYState = function buildXYState(xyCoords /* Number[] */, brightness, transitionTimeOverride) {
        var stateObj = { xy: xyCoords };
        if (typeof brightness === 'number') {
            stateObj.bri = brightness;}

        addTransitionTime(stateObj, transitionTimeOverride);
        return stateObj;}, 


    /** 
     * Builds a JSON state object for the hue, saturation, and brightness provided.
     * @param {Number} hue from 0 to 65535.
     * @param {Number} sat from 0 to 255.
     * @param {Number} bri from 0 to 255.
     * @return {Object} State object containing CIE X,Y coordinates.
     */
    buildHueSatState = function buildHueSatState(hue, sat, brightness, transitionTimeOverride) {
        var stateObj = { hue: hue, sat: sat };
        if (typeof brightness === 'number') {
            stateObj.bri = brightness;}

        addTransitionTime(stateObj, transitionTimeOverride);
        return stateObj;}, 

    addTransitionTime = function addTransitionTime(stateObj, transitionTimeOverride) {
        if (typeof transitionTime === 'number') {
            stateObj.transitiontime = transitionTime;}

        if (typeof transitionTimeOverride === 'number') {
            stateObj.transitiontime = transitionTimeOverride;}}, 


    buildSceneState = function buildSceneState(sceneKey, transitionTimeOverride) {
        var stateObj = { scene: sceneKey };
        addTransitionTime(stateObj, transitionTimeOverride);
        return stateObj;}, 


    /**
     * Returns the brightness of the lamp at lampIndex.
     *
     * @param {Number} lampIndex 1-based index of the lamp to query.
     * @return {Number} Brightness of the lamp at lampIndex. 0 - 255.
     */
    getBrightness = function getBrightness(lampIndex /* Number */, success) {
        get(buildLampQueryURL(lampIndex), function (data) {
            // success
            if (data.state === undefined) {
                // fail
                return;}

            success(data.state.bri);}, 
        function (err) {
            err = null;
            // fail
        });
        //return lampState.state.bri;
    }, 

    /**
     * Builds a JSON state object used to set the brightness of a Hue lamp to
     * the value of the brightness parameter.
     *
     * @param {Number} brightness Integer value between 0 and 255. Note that 0
     * is not equivalent to the lamp's off state.
     * @return {Object} JSON object used to set brightness.
     */
    buildBrightnessState = function buildBrightnessState(brightness, transitionTimeOverride) {
        var stateObj = { bri: Number(brightness) };
        addTransitionTime(stateObj, transitionTimeOverride);
        return stateObj;}, 


    adjustBrightness = function adjustBrightness(lampId, brightness, success) {
        brightness = Number(brightness);
        getBrightness(lampId, function (currentBrightness) {
            var adjustedBrightness = currentBrightness + brightness;
            var newBrightness = adjustedBrightness < 255 ? adjustedBrightness : 254;
            newBrightness = adjustedBrightness > 0 ? adjustedBrightness : 0;
            success(Math.round(newBrightness));});}, 


    getLightState = function getLightState() {
        bridge.getLightState(onLightUpdate);}, 

    onLightUpdate = function onLightUpdate(bridge, ip, username, status, data) {
        if (data !== null && state !== null) {
            state.lights = data.lights;}}, 


    // todo: why does this repeat getLightState?
    getBridgeState = function getBridgeState() {
        bridge.getLightState(onLightUpdate);}, 

    onNewState = function onNewState(data) {
        //log('Authorized');
        /* jshint ignore:start */
        if (!(typeof testData === 'undefined')) {
            data = testData;}

        /* jshint ignore:end */

        // cache state
        state = data;
        // re-create virtual All group:
        var lampIds = $.map(state.lights, function (lamp, key) {
            return key;});

        state.groups['0'] = { 
            name: 'All', 
            lights: lampIds, 
            type: 'LightGroup', 
            action: {} };


        //log('hue: saving state - ' + JSON.stringify(data));

        numberOfLamps = Object.keys(data.lights).length;
        var message = 'No  lights found';
        if (numberOfLamps === 0) {
            message = 'No lights found.';} else 
        if (numberOfLamps === 1) {
            message = 'One light found.';} else 
        {
            message = '' + numberOfLamps + ' lights found.';}


        log('Updating Status - ok...');
        updateStatus('OK', message);}, 


    /**
     * Log to console
     */
    updateStatus = function updateStatus(inStatus, text, data) {
        var newStatus = { status: inStatus, text: text, data: data };
        onStatus(newStatus);}, 

    onStatus = function onStatus(newStatus) {
        if (JSON.stringify(status) !== JSON.stringify(newStatus)) {
            console.log('hue: status change, ' + newStatus.status + ', text: ' + newStatus.text + ', data: ' + newStatus.data);
            status = newStatus;}}, 


    log = function log(text) {
        console.log('hue: ' + text);
        if (typeof logHandler !== 'undefined') {
            logHandler(text);}}, 


    _setHueSatState = function _setHueSatState(lampIndex, hue, sat, bri, transitiontime) {
        var state = buildHueSatState(hue, sat, bri, transitiontime);
        put(lampIndex, state);}, 

    _setXYState = function _setXYState(lampIndex /* Number */, xy, transitiontime, bri) {
        var state = buildXYState(xy, bri, transitiontime);
        put(lampIndex, state);};


    return { 
        /** 
         * Flash the lamp at lampIndex for a short time. 
         *	
         * @param {Number} lampIndex 1-based index of the Hue lamp to flash.
         * @return {Object} JSON object containing lamp state.
         */
        flash: function flash(lampIndex /* Number */) {
            return put(lampIndex, shortFlashState);}, 

        /** 
         * Flash all connected lamps for a short time.
         *
         * @return {Object} JSON object containing lamp state.
         */
        flashAll: function flashAll() {
            return putAll(shortFlashState);}, 

        /** 
         * Flash the lamp at lampIndex for a long time.
         *
         * @param {Number} lampIndex 1-based index of the Hue lamp to flash.
         * @return {Object} JSON object containing lamp state.
         */
        longFlash: function longFlash(lampIndex /* Number */) {
            return put(lampIndex, longFlashState);}, 

        /** 
         * Flash all connected lamps for a long time.
         *
         * @return {Object} JSON object containing lamp state.
         */
        longFlashAll: function longFlashAll() {
            return putAll(longFlashState);}, 

        /** 
         * Set the lamp at lampIndex to the approximate CIE x,y equivalent of 
         * the provided hex color.
         *
         * @param {Number} lampIndex 1-based index of the Hue lamp to colorize.
         * @param {String} color String representing a hexadecimal color value.
         * @return {Object} JSON object containing lamp state.
         */
        setColor: function setColor(lampIndex /* Number */, color /* String */, transitiontime, brightness) {
            var xy = colors.getCIEColor(color);
            if (typeof brightness === 'number') {
                if (brightness < 0) {// min
                    // adjust it:
                    var bri = colorUtil().getBrightness(color);
                    adjustBrightness(lampIndex, bri, function (bri) {
                        _setXYState(lampIndex, xy, transitiontime, bri);});

                    return;}

                _setXYState(lampIndex, xy, transitiontime, brightness);} else 

            {
                _setXYState(lampIndex, xy, transitiontime, null);}}, 


        setXYState: function setXYState(lampIndex, xy, transitiontime, bri) {
            _setXYState(lampIndex, xy, transitiontime, bri);}, 

        /** 
         * Sets state for the hue, saturation, and brightness provided.
         * @param {Number} hue from 0 to 65535.
         * @param {Number} sat from 0 to 255.
         * @param {Number} bri from 0 to 255.
         * @return {Object} State object containing CIE X,Y coordinates.
         */
        setHueSatState: function setHueSatState(lampIndex, hue, sat, bri, transitiontime) {
            _setHueSatState(lampIndex, hue, sat, bri, transitiontime);}, 


        /**
         * Sets all connected lamps to the approximate CIE x,y equivalent of 
         * the provided hex color.
         *
         * @param {String} color String representing a hexadecimal color value.
         * @return {Object} JSON object containing lamp state.
         */
        setAllColors: function setAllColors(color /* String */) {
            var xy = colors.getCIEColor(color);
            colorUtil().getBrightness(color, function (bri) {
                var state = buildXYState(xy, bri);
                putGroupAction(0, state);});}, 


        createGroup: function createGroup(name, lights) {
            return postGroup(name, lights);}, 

        removeGroup: function removeGroup(key) {
            return deleteGroup(key);}, 

        /** 
         * Turn on scene by key
         */
        startScene: function startScene(sceneKey) {
            var state = buildSceneState(sceneKey);
            return putGroupAction(0, state);
            //var scene = hue.getState().scenes[sceneKey];
            //if (scene !== undefined) {
            //var state = buildSceneState(sceneKey);
            //$.each(scene.lights, function(index, val){
            //    put(val, state);
            //});       
            //}
        }, 
        /**
         * Turn off the lamp at lampIndex.
         *
         * @param {Number} lampIndex 1-based index of the Hue lamp to turn off.
         * @return {Object} JSON object containing lamp state.
         */
        turnOff: function turnOff(lampIndex /* Number */) {
            return put(lampIndex, offState);}, 

        /** 
         * Turn on the lamp at lampIndex.
         *
         * @param {Number} lampIndex 1-based index of the Hue lamp to turn on.
         * @return {Object} JSON object containing lamp state.
         */
        turnOn: function turnOn(lampIndex /* Number */) {
            return put(lampIndex, onState);}, 

        /** 
         * Turn off all connected lamps.
         *
         * @return {Object} JSON object containing lamp state.
         */
        turnOffAll: function turnOffAll() {
            if (status.status === 'OK') {status.data = false;}
            return putGroupAction(0, offState);}, 

        /** 
         * Turn on all connected lamps.
         *
         * @return {Object} JSON object containing lamp state.
         */
        turnOnAll: function turnOnAll() {
            if (status.status === 'OK') {status.data = true;}
            return putGroupAction(0, onState);}, 

        /**
         * Set the brightness of the lamp at lampIndex.
         *
         * @param {Number} lampIndex 1-based index of the Hue lamp to modify.
         * @param {Number} brightness Integer value between 0 and 254.
         * @return {Object} JSON object containing lamp state.
         */
        setBrightness: function setBrightness(lampIndex /* Number */, brightness /* Number */, transitiontime /* Number */) {
            var state = buildBrightnessState(brightness, transitiontime);
            return put(lampIndex, state);}, 

        /**
         * Set the brightness of all connected lamps.
         *
         * @param {Number} brightness Integer value between 0 and 254.
         * @return {Object} JSON object containing all lamp state.
         */
        setAllBrightness: function setAllBrightness(brightness /* Number */) {
            var state = buildBrightnessState(brightness);
            return putGroupAction(0, state);}, 

        /**
         * Set the brightness of an indexed group of lamps.
         *
         * @param {Number} groupIndex 0-based lamp group index.
         * @param {Number} brightness Integer value between 0 and 254.
         * @return {Object} JSON object containing group state.
         */
        setGroupBrightness: function setGroupBrightness(groupIndex /* Number */, brightness /* Number */) {
            var state = buildBrightnessState(brightness);
            return putGroupAction(groupIndex, state);}, 

        /**
         * Dim the lamp at lampIndex by decrement.
         * 
         * @param {Number} lampIndex 1-based lamp index.
         * @param {Number} [decrement] Amount to decrement brightness by (between 0 and 255).
         * @return {Object} JSON object containing lamp state.
         */
        dim: function dim(lampIndex /* Number */, decrement /* Number */, transitiontime) {
            decrement = decrement || -10; // default to 10 if decrement not provided.
            adjustBrightness(lampIndex, decrement, function (newBrightness) {
                return put(lampIndex, buildBrightnessState(newBrightness, transitiontime));});}, 


        /**
         * Dim all lamps by decrement.
         * 
         * @param {Number} [decrement] Amount to decrement brightness by (between 0 and 255).
         * @return {Object[]} JSON objects containing lamp states.
         */
        dimAll: function dimAll(decrement /* Number */) {
            var states = [];
            for (var i = 0; i < numberOfLamps; ++i) {
                states[i] = this.dim(i + 1, decrement);}

            return states;}, 

        /**
         * Brighten the lamp at lampIndex by increment.
         *
         * @param {Number} lampIndex 1-based lamp index.
         * @param {Number} [increment] Amount to increment brightness by (between 0 and 255).
         * @return {Object} JSON object containing lamp state.
         */
        brighten: function brighten(lampIndex, increment, transitiontime) {
            increment = increment || 10;
            adjustBrightness(lampIndex, increment, function (newBrightness) {
                //this.setBrightness(lampIndex, newBrightness, transitiontime);
                return put(lampIndex, buildBrightnessState(newBrightness, transitiontime));});}, 


        /**
         * Brighten all lamps by increment.
         *
         * @param {Number} [increment] Amount to increment brightness by (between 0 and 255).
         * @return {Object[]} JSON objects containing lamp states.
         */
        brightenAll: function brightenAll(increment /* Number */) {
            var states = [];
            for (var i = 0; i < numberOfLamps; ++i) {
                states[i] = this.brighten(i + 1, increment);}

            return states;}, 

        /** 
         * Return the value of the configured transitionTime property.
         *
         * @return {Number} Value of the transitionTime property. Null by default if not
         * set.
         */
        getTransitionTime: function getTransitionTime() {
            return transitionTime;}, 

        /**
         * Set the value of the transitionTime property.
         *
         * @param {Number} time Lamp color transition time in approximate milliseconds.
         */
        setTransitionTime: function setTransitionTime(time /* Number */) {
            transitionTime = time;}, 

        /**
         * Find bridges  findBridge() a upnp, then scan, then predefined typical ips. 
         */
        //findBridge: function(onerror) {
        // deprecated, use discover 
        //},
        /**
         * Set the number of lamps available to control.
         *
         * @param {Number} The total number of lamps available to interact with. Default is 3.
         */
        setNumberOfLamps: function setNumberOfLamps(numLamps /* Number */) {
            if (typeof numLamps === 'number') {
                numberOfLamps = numLamps;}}, 


        setLogger: function setLogger(func) {
            console.log('new subscriber to log change registered;');
            logHandler = func;}, 

        getState: function getState() {
            return state;}, 

        getStatus: function getStatus() {
            return status;}, 

        refresh: function refresh() {
            getBridgeState();}, 

        heartbeat: function heartbeat() {
            getLightState();}, 

        getLampIds: function getLampIds(actors) {
            // parse actors
            //actors
            if (actors === null) {
                return []; // no lamps
            }
            if (actors.substring(0, 'group-'.length) === 'group-') 
            {
                var group = actors.substring('group-'.length);
                if (state.groups[group] === undefined) {
                    // error.
                    return [];}

                return state.groups[group].lights;}

            return [actors]; // lights: prefix not used, just return array of number.
        }, 
        discover: function discover(ip) {
            rediscover(ip);} };};





function findActors(key) {
    return findGroupIdByName(key);}


function findGroupIdByName(name) {
    if (name.toLowerCase() === 'all') {
        return '0'; // special case group-0 is all.
    }
    var state = window.hue.getState();
    if (state !== null) {
        for (var group in state.groups) {
            if (state.groups[group].name.toLowerCase() === name.toLowerCase()) {
                return group;}}}



    return null;}
/**
 * Dmitry Sadakov's Color Util
 * Copyright (c) 2014 Dmitry Sadakov, All rights reserved. */

'use strict'

/*exported colorUtil */;
var colorUtil = function colorUtil() {


    function colourNameToHex(colour) 
    {
        var colours = { 
            'aliceblue': '#f0f8ff', 
            'antiquewhite': '#faebd7', 
            'aqua': '#00ffff', 
            'aquamarine': '#7fffd4', 
            'azure': '#f0ffff', 
            'beige': '#f5f5dc', 
            'bisque': '#ffe4c4', 
            'black': '#000000', 
            'blanchedalmond': '#ffebcd', 
            'blue': '#0000ff', 
            'blueviolet': '#8a2be2', 
            'brown': '#a52a2a', 
            'burlywood': '#deb887', 
            'cadetblue': '#5f9ea0', 
            'chartreuse': '#7fff00', 
            'chocolate': '#d2691e', 
            'coral': '#ff7f50', 
            'cornflowerblue': '#6495ed', 
            'cornsilk': '#fff8dc', 
            'crimson': '#dc143c', 
            'cyan': '#00ffff', 
            'darkblue': '#00008b', 
            'darkcyan': '#008b8b', 
            'darkgoldenrod': '#b8860b', 
            'darkgray': '#a9a9a9', 
            'darkgreen': '#006400', 
            'darkkhaki': '#bdb76b', 
            'darkmagenta': '#8b008b', 
            'darkolivegreen': '#556b2f', 
            'darkorange': '#ff8c00', 
            'darkorchid': '#9932cc', 
            'darkred': '#8b0000', 
            'darksalmon': '#e9967a', 
            'darkseagreen': '#8fbc8f', 
            'darkslateblue': '#483d8b', 
            'darkslategray': '#2f4f4f', 
            'darkturquoise': '#00ced1', 
            'darkviolet': '#9400d3', 
            'deeppink': '#ff1493', 
            'deepskyblue': '#00bfff', 
            'dimgray': '#696969', 
            'dodgerblue': '#1e90ff', 
            'firebrick': '#b22222', 
            'floralwhite': '#fffaf0', 
            'forestgreen': '#228b22', 
            'fuchsia': '#ff00ff', 
            'gainsboro': '#dcdcdc', 
            'ghostwhite': '#f8f8ff', 
            'gold': '#ffd700', 
            'goldenrod': '#daa520', 
            'gray': '#808080', 
            'green': '#008000', 
            'greenyellow': '#adff2f', 
            'honeydew': '#f0fff0', 
            'hotpink': '#ff69b4', 
            'indianred ': '#cd5c5c', 
            'indigo': '#4b0082', 
            'ivory': '#fffff0', 
            'khaki': '#f0e68c', 
            'lavender': '#e6e6fa', 
            'lavenderblush': '#fff0f5', 
            'lawngreen': '#7cfc00', 
            'lemonchiffon': '#fffacd', 
            'lemon': '#fffacd', 
            'lightblue': '#add8e6', 
            'lightcoral': '#f08080', 
            'lightcyan': '#e0ffff', 
            'lightgoldenrodyellow': '#fafad2', 
            'lightgrey': '#d3d3d3', 
            'lightgreen': '#90ee90', 
            'lightpink': '#ffb6c1', 
            'lightsalmon': '#ffa07a', 
            'lightseagreen': '#20b2aa', 
            'lightskyblue': '#87cefa', 
            'lightslategray': '#778899', 
            'lightsteelblue': '#b0c4de', 
            'lightyellow': '#ffffe0', 
            'lime': '#00ff00', 
            'limegreen': '#32cd32', 
            'linen': '#faf0e6', 
            'magenta': '#ff00ff', 
            'maroon': '#800000', 
            'mediumaquamarine': '#66cdaa', 
            'mediumblue': '#0000cd', 
            'mediumorchid': '#ba55d3', 
            'mediumpurple': '#9370d8', 
            'mediumseagreen': '#3cb371', 
            'mediumslateblue': '#7b68ee', 
            'mediumspringgreen': '#00fa9a', 
            'mediumturquoise': '#48d1cc', 
            'mediumvioletred': '#c71585', 
            'midnightblue': '#191970', 
            'mintcream': '#f5fffa', 
            'mistyrose': '#ffe4e1', 
            'moccasin': '#ffe4b5', 
            'navajowhite': '#ffdead', 
            'navy': '#000080', 
            'oldlace': '#fdf5e6', 
            'olive': '#808000', 
            'olivedrab': '#6b8e23', 
            'orange': '#ffa500', 
            'orangered': '#ff4500', 
            'orchid': '#da70d6', 
            'palegoldenrod': '#eee8aa', 
            'palegreen': '#98fb98', 
            'paleturquoise': '#afeeee', 
            'palevioletred': '#d87093', 
            'papayawhip': '#ffefd5', 
            'peachpuff': '#ffdab9', 
            'peru': '#cd853f', 
            'pink': '#ffc0cb', 
            'plum': '#dda0dd', 
            'powderblue': '#b0e0e6', 
            'purple': '#800080', 
            'red': '#ff0000', 
            'rosybrown': '#bc8f8f', 
            'royalblue': '#4169e1', 
            'saddlebrown': '#8b4513', 
            'salmon': '#fa8072', 
            'sandybrown': '#f4a460', 
            'seagreen': '#2e8b57', 
            'seashell': '#fff5ee', 
            'sienna': '#a0522d', 
            'silver': '#c0c0c0', 
            'skyblue': '#87ceeb', 
            'slateblue': '#6a5acd', 
            'slategray': '#708090', 
            'snow': '#fffafa', 
            'springgreen': '#00ff7f', 
            'steelblue': '#4682b4', 
            'tan': '#d2b48c', 
            'teal': '#008080', 
            'thistle': '#d8bfd8', 
            'tomato': '#ff6347', 
            'turquoise': '#40e0d0', 
            'violet': '#ee82ee', 
            'wheat': '#f5deb3', 
            'white': '#ffffff', 
            'whitesmoke': '#f5f5f5', 
            'yellow': '#ffff00', 
            'yellowgreen': '#9acd32', 

            'minty': '#98FF98', 
            'coldwhite': '#FFF4E5', 
            'warmwhite': '#D4EBFF' };


        // if key exists
        if (typeof colours[colour.toLowerCase()] !== 'undefined') {
            return colours[colour.toLowerCase()];}


        return false;}


    function isColorHex(hex) {
        var isColor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
        if (isColor) {
            return true;}

        return false;}


    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;}


    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;});


        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? { 
            r: parseInt(result[1], 16), 
            g: parseInt(result[2], 16), 
            b: parseInt(result[3], 16) } : 
        null;}

    /*
    //Converts to color HSB object (code from here 
    // http://www.csgnetwork.com/csgcolorsel4.html 
    //with some improvements)
    function rgb2hsb(r, g, b) {    
        r /= 255; g /= 255; b /= 255; // Scale to unity.   
        var minVal = Math.min(r, g, b),
        maxVal = Math.max(r, g, b),
        delta = maxVal - minVal,
        HSB = {hue:0, sat:0, bri:maxVal},
        del_R, del_G, del_B;
          if( delta !== 0 ) {
            HSB.sat = delta / maxVal;
            del_R = (((maxVal - r) / 6) + (delta / 2)) / delta;
            del_G = (((maxVal - g) / 6) + (delta / 2)) / delta;
            del_B = (((maxVal - b) / 6) + (delta / 2)) / delta;
              if (r === maxVal) {HSB.hue = del_B - del_G;}
            else if (g === maxVal) {HSB.hue = (1 / 3) + del_R - del_B;}
            else if (b === maxVal) {HSB.hue = (2 / 3) + del_G - del_R;}
              if (HSB.hue < 0) {HSB.hue += 1;}
            if (HSB.hue > 1) {HSB.hue -= 1;}
        }
          HSB.hue *= 360;
        HSB.sat *= 100;
        HSB.bri *= 100;
          return HSB;
    }
    */






    return { 
        getColor: function getColor(command) {
            //log('get color: ' + command);

            var foundColor = colourNameToHex(command);
            if (foundColor !== false) {
                return foundColor;}


            var isColor = isColorHex(command);
            if (isColor) {
                return command;}

            return false;}, 

        getBrightness: function getBrightness(hex) {
            var rgb = hexToRgb(hex);
            return Math.round(0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b);}, 

        rgbToHex: function rgbToHex(r, g, b) {
            return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);} };};
/**
 * Dmitry Sadakov's Philips Hue Commander wrapper, exposed as an AMD module.
 * Dependencies:
 *    - jQuery 1.8.3
 *    - colors.js (packaged alongside this file)
 * Copyright (c) 2014 Dmitry Sadakov, All rights reserved. */

/*globals trackEvent, $, findActors */
/*exported 
    hueCommander,
    executeCommand,
    activatedScene
 */

'use strict';

var hueCommander = function hueCommander($, hue, colorUtil, sceneCmd) {

    var logger = null, 
    actorId = null, 
    stateCache = null, 
    executeCommand = function executeCommand(command) {
        log('executing command: ' + command + ' on actor: ' + actorId);
        trackEvent('huecommander', 'command', command);

        if (actorId === null) {
            // by default set all group
            var groupAll = findActors('All');
            if (groupAll === null) {
                actorId = 'group-1';} else 
            {
                actorId = 'group-' + groupAll;}}



        if (command === undefined) {
            return;}

        if (command === 'brighten' || command === 'up') {
            //hue.brightenAll(Math.floor(255 / 3));
            executeOnActors(function (bulb) {
                hue.brighten(bulb, Math.floor(255 / 3));});}


        if (command === 'darken' || command === 'dim' || command === 'dim down' || command === 'down') {
            //hue.brightenAll(Math.floor(-255 / 3));
            executeOnActors(function (bulb) {
                hue.dim(bulb, -Math.floor(255 / 3));});}


        if (command === 'on') {
            executeOnActors(function (bulb) {
                hue.turnOn(bulb);});

            return;}

        if (command === 'off') {
            executeOnActors(function (bulb) {
                hue.turnOff(bulb);});

            return;}

        var json = parseJson(command);
        if (json !== null) 
        {
            // hue, sat, bri command:
            if ('hue' in json) {
                executeOnActors(function (bulb) {
                    hue.setHueSatState(bulb, json.hue, json.sat, json.bri, json.time);});

                return;} else 
            if ('bri' in json) {
                executeOnActors(function (bulb) {
                    hue.setBrightness(bulb, json.bri);});

                return;}

            //else if('color' in json) {
            //    hue.setColor(color.substring(1));
            //}
        }
        var bri = detectBrightness(command);
        if (bri !== null) {
            executeOnActors(function (bulb) {
                hue.setBrightness(bulb, bri);});

            return;}

        var color = colorUtil.getColor(command);
        if (color !== false) {
            executeOnActors(function (bulb) {
                hue.setColor(bulb, color.substring(1));});

            return;}


        if (command === 'scene:stop') {
            sceneCmd.stop();
            restoreState();
            return 'stop';} else 
        {
            if (command.lastIndexOf('scene:', 0) === 0) {
                var sceneName = command.substring(6);
                var lampids = hue.getLampIds(actorId);

                saveState();

                sceneCmd.start(sceneName, lampids);
                return sceneName;}}}, 



    parseJson = function parseJson(cmd) {
        try {
            if (cmd.startsWith('{')) {
                return JSON.parse(cmd);}} 


        catch (ex) 
        {
            log('Bad command:' + cmd + ' ex:' + ex.message);}

        return null;}, 

    saveState = function saveState() {
        if (stateCache === null) {
            stateCache = getActorStatesInternal();
            log('Saved state' + JSON.stringify(stateCache));}}, 


    restoreState = function restoreState() {
        if (stateCache !== null) {
            var newstate = stateCache;
            stateCache = null;
            log('Restoring state' + JSON.stringify(newstate));
            $.each(newstate, function (key, value) {
                hue.setXYState(value.key, value.state.xy, 0, value.state.bri);});

            hue.heartbeat(); // force refresh from bridge
        }}, 

    executeOnActors = function executeOnActors(func) {
        sceneCmd.stop();
        restoreState();

        var lampIds = hue.getLampIds(actorId);
        if (!$.isArray(lampIds)) {
            lampIds = [lampIds];}

        $.each(lampIds, function (index, val) {
            func(val, index);});}, 


    detectBrightness = function detectBrightness(command) {
        if (command === undefined) {
            return null;}

        if (command.startsWith('bri:')) {
            return command.substring('bri:'.length);}

        return null;}, 

    log = function log(text) {
        if (logger !== null) {
            logger(text);}}, 


    getActorStatesInternal = function getActorStatesInternal() {
        var lampIds = hue.getLampIds(actorId);
        var state = window.hue.getState();
        var actorStates = [];
        if (state.lights !== null) {
            for (var i in state.lights) {
                var lamp = state.lights[i];
                lamp.key = i;
                if (lampIds.indexOf(i) !== -1) {
                    actorStates.push(lamp);}}}



        return actorStates;}, 

    getActorBrightnessInternal = function getActorBrightnessInternal() {
        var bri = 0;
        var actors = getActorStatesInternal();
        $.each(actors, function (key, lamp) {
            if (lamp.state.bri > bri) {
                bri = lamp.state.bri;}});


        return bri;}, 

    getActorTurnedOn = function getActorTurnedOn() {
        var on = false;
        var actors = getActorStatesInternal();
        $.each(actors, function (key, lamp) {
            on = on || lamp.state.on;});

        return on;}, 

    _discover = function _discover(ip) {
        hue.discover(ip);}, 

    _heartbeat = function _heartbeat() {
        hue.heartbeat();}, 

    _createGroup = function _createGroup(name, lampIds) {
        hue.createGroup(name, lampIds);}, 

    _removeGroup = function _removeGroup(key) {
        hue.removeGroup(key);}, 

    _refresh = function _refresh() {
        hue.refresh();}, 

    _flash = function _flash(key) {
        hue.flash(key);}, 

    _getState = function _getState() {
        var state = hue.getState();
        state.actorId = actorId;
        return state;}, 

    _getStatus = function _getStatus() {
        return hue.getStatus();}, 

    _palette = function _palette(colors) {
        return sceneCmd.palette(colors);};




    return { 
        setActor: function setActor(actor) {
            actorId = actor;
            return actorId;}, 

        getActor: function getActor(actor) {
            return actorId;}, 

        getActorBrightness: function getActorBrightness() {
            return { 
                bri: getActorBrightnessInternal(), 
                on: getActorTurnedOn() };}, 


        getActorStates: function getActorStates() {
            return getActorStatesInternal();}, 

        command: function command(commandText) {
            return executeCommand(commandText);}, 

        setLogger: function setLogger(logHandler) {
            logger = logHandler;}, 

        discover: function discover(ip) {
            _discover(ip);}, 

        heartbeat: function heartbeat() {
            _heartbeat();}, 

        createGroup: function createGroup(group) {
            //name, lampIds){
            _createGroup(group.name, group.lampIds);}, 

        removeGroup: function removeGroup(key) {
            _removeGroup(key);}, 

        refresh: function refresh() {
            _refresh();}, 

        flash: function flash(key) {
            _flash(key);}, 

        getState: function getState() {
            return _getState();}, 

        getStatus: function getStatus() {
            return _getStatus();}, 

        palette: function palette(colors) {
            return _palette(colors);}, 

        parse: function parse(cmd) {
            return this[cmd.hueCommand.command](cmd.hueCommand.args);} };};





function executeCommand(command) {
    window.hueCommander.command(command);
    //activatedScene('stop');
    return false;}


function activatedScene(key) {
    $('#scenes button').removeClass('active');
    $('.scene').removeClass('active');
    $('#scenes button[id="' + key + '"]').addClass('active');
    $('.scene[data-scene="' + key + '"]').addClass('active');}
/**
 * Dmitry Sadakov's Philips Hue app
 */

'use strict'

/* globals chrome */
/*exported hueProxy
*/;

var hueProxy = function hueProxy(hueCommander) {

    function sendToMothership(obj, args, callback) {
        if (hueCommander) {
            var result = hueCommander.parse(obj, args);
            if (result && callback) {
                callback(result);}} else 

        {
            //var editorExtensionId = 'bkjobgdhkjdholiipmcdbaefnoacfkcc';
            var editorExtensionIdProd = 'ahcbfmbmpojngalhbkkggbfamgmkneoo';
            //chrome.runtime.sendMessage(editorExtensionId, obj, callback);
            chrome.runtime.sendMessage(editorExtensionIdProd, obj, callback);}}



    function hueCommand(command, args, callback) {
        if (typeof args === 'function') {
            // reorder arguments if second is skipped
            callback = args;
            args = undefined;}

        var obj = { 
            hueCommand: { 
                command: command, 
                args: args } };


        sendToMothership(obj, args, callback);}


    return { 
        cmd: hueCommand, 
        sendToMothership: sendToMothership };};
'use strict'
/* jshint ignore:start */;

var Presenter = { 
	makeDocument: function makeDocument(resource) {
		if (!Presenter.parser) {
			Presenter.parser = new DOMParser();}

		var doc = Presenter.parser.parseFromString(resource, 'application/xml');
		return doc;}, 


	modalDialogPresenter: function modalDialogPresenter(xml) {
		navigationDocument.presentModal(xml);}, 


	pushDocument: function pushDocument(xml) {
		navigationDocument.pushDocument(xml);}, 


	load: function load(event) {
		var self = this, 
		ele = event.target, 
		videoURL = ele.getAttribute('videoURL');
		if (videoURL) {
			var player = new Player();
			var playlist = new Playlist();
			var mediaItem = new MediaItem('video', videoURL);

			player.playlist = playlist;
			player.playlist.push(mediaItem);
			player.present();}} };




/* jshint ignore:end */
'use strict'
/* jshint ignore:start */;

function ResourceLoader(baseurl) {
	this.BASEURL = baseurl;}


ResourceLoader.prototype.loadResource = function (resource, callback) {
	var self = this;
	evaluateScripts([resource], function (success) {
		if (success) {
			var resource = Template.call(self);
			callback.call(self, resource);} else 
		{
			var title = 'Resource Loader Error';
			description = 'Error loading resource \'' + resource + '\'. \n\n Try again later.', 
			alert = createAlert(title, description);
			navigationDocument.presentModal(alert);}});};




/* jshint ignore:end */
'use strict'
/* jshint ignore:start */;


if (navigationDocument !== undefined) {

  var resourceLoader;

  App.onLaunch = function (options) {
    console.log('loaded tvos js.');
    //debugger;

    window.hue = hue(AjaxLite, window.colors);
    sceneCmd = sceneCommander(AjaxLite, window.hue);
    //ambieye = window.Ambient;
    window.hueCommander = hueCommander(AjaxLite, window.hue, colorUtil(), sceneCmd);
    //window.hueProxy = hueProxy(window.hueCommander);
    //ambieye.onUpdate(updatePreviewColors);

    hueProxy.cmd('discover');
    //var h = HueDiscoverer();
    //h.discover();


    return;
    /*
    var javascriptFiles = [
     //`${options.BASEURL}js/ResourceLoader.js`,
     //`${options.BASEURL}js/Presenter.js`,
     //`${options.BASEURL}js/hue/hueTest.js`
     //`${options.BASEURL}js/vendor/jquery-2.1.4.js`
    ];
      evaluateScripts(javascriptFiles, function(success) {
      if(success) {
        resourceLoader = new ResourceLoader(options.BASEURL);
        resourceLoader.loadResource(`${options.BASEURL}templates/RWDevConTemplate.xml.js`, function(resource) {
          var doc = Presenter.makeDocument(resource);
          doc.addEventListener("select", Presenter.load.bind(Presenter));
          Presenter.pushDocument(doc);
            flashLight();
        })
      } else {
        var errorDoc = createAlert("Evaluate Scripts Error", "Error attempting to evaluate external JavaScript files.");
        navigationDocument.presentModal(errorDoc);
      }
    });
    */};




  var createAlert = function createAlert(title, description) {
    var alertString = '<?xml version="1.0" encoding="UTF-8" ?>\n      <document>\n        <alertTemplate>\n          <title>' + 


    title + '</title>\n          <description>' + 
    description + '</description>\n          <button>\n            <text>OK</text>\n          </button>\n        </alertTemplate>\n      </document>';





    var parser = new DOMParser();
    var alertDoc = parser.parseFromString(alertString, "application/xml");
    return alertDoc;};}






/* jshint ignore:end */